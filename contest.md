# Our solution introduced:

- New UI for folder tabs
- A setting (on the Chat Folder page) to choose the old or new Folder UI
- WebGL-based gradient backgrounds 
- Optimizations and fixes for Composer component
- New flexible and reusable RichInput component
- Improved markdown parser
    
# Detailed description


## Folders 

Folders are implemented mostly with CSS, with only icons rendering conditionally 
in TS, thus making the solution performance and flexible: as a proof of that,
we've **implemented a setting field, that allows you to choose between old and new
layouts (see Chat Folder settings page)**.

For storing icons or emoji for the folder, we **used localStorage** (see 
LOCSTOR_CUSTOM_EMOJI_KEY) instead of the folder name, storing all the necessary
for the display info the way similar to MacOS's. This approach brings no folder
title parsing or storing things sparsely, as you may just swap localStorage calls 
with a new API, thus making the future rewrite (when the API is ready) easier.

## Backgrounds 

Settings support as many backgrounds as any other official telegram client, 
including gradient ones. You may easily switch between them and even see (when 
the animations are turned on) how **the previews rotate with mouse hover** or with 
taps, if the device supports touches.

Gradient rendering for pattern-based backgrounds was implemented with **WebGL and
custom shader**. We discovered, that the shader, suggested by organisers, produces 
different gradient, compared to other clients (Android, QT, WebK). Thus **we wrote 
custom shader**, inspired by that code, which **rendered the background correctly** and 
on GPU.

## Rich Text Editor

Creating **fully custom editor, that doesn't rely on execCommand, proved to be 
unnecessary complicated**, considering limited formatting options required by 
Telegram and it being susceptible to cross browser differences. Thus we mainly 
focused on **reducing problems introduced by execCommand**.

For avoid questionable HTML generated by regexp's, we **rewrote parser from scratch**
and put it after the stage of generating HTML, which significantly improved 
combining UI-created formatting and markdown syntax. We decided against creating
full AST from markdown, as it was unnecessary heavy and could drastically 
overcomplicate things. So, we settled on token-based approach, which generates 
ApiMessageEntity'es for further use.

Additionally **to allow reuse of rich editing in other areas (e.g. Quizz hints or 
Gifts messages)**, we have moved the core logic into separate class RichEditable. 
The class handles all common functions, related to contentEditable and allows 
attachment to different points in the Teact tree. To reduce the load, when using 
smile search synax (f.e. :smile) and handles (f.e. @wiki), we added some 
additional logic. Composer **was modified (with some parts rewritten completely) in
a way to accommodate those changes**. Additionally, to prove **our RichInput 
component being a lightweight and flexible solution** for markdown and WYSIWYG 
text editing, we integrated it into **Gifting modal (for the gift message) and 
Quiz modal (for the hint text)**.